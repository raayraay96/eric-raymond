<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 7-DOF Portfolio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow-x: hidden; /* Only prevent horizontal scroll */
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
            min-height: 100vh;
        }
        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Behind content */
            pointer-events: auto; /* Allow interaction */
        }
        .glass-card {
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }
        .content-wrapper {
            position: relative;
            z-index: 10; /* Above canvas */
            width: 100%;
            min-height: 100vh;
            overflow-y: auto;
            overflow-x: hidden;
            background: transparent; /* Make content transparent */
        }
    </style>
</head>
<body class="text-white">

    <canvas id="bg-canvas"></canvas>

    <div class="content-wrapper">
        <div class="container mx-auto px-6 py-8">
            
            <header class="flex justify-between items-center mb-16 md:mb-24">
                <div class="flex items-center space-x-2">
                    <svg class="w-8 h-8 text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783-.57-1.838-.196-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.783-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z"></path></svg>
                    <span class="text-xl font-bold">ERIC RAYMOND</span>
                </div>
                <nav class="hidden md:flex items-center space-x-8">
                    <a href="#home" class="hover:text-purple-400 transition-colors">Home</a>
                    <a href="#about" class="hover:text-purple-400 transition-colors">About</a>
                    <a href="#projects" class="hover:text-purple-400 transition-colors">Projects</a>
                    <a href="#skills" class="hover:text-purple-400 transition-colors">Skills</a>
                    <a href="#contact" class="hover:text-purple-400 transition-colors">Contact</a>
                </nav>
                <button class="bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-5 rounded-lg transition-colors">
                    Get In Touch
                </button>
            </header>

            <main>
                <h1 class="text-4xl md:text-6xl font-bold mb-4 text-center">AI/ML Systems Engineer</h1>
                <p class="text-lg md:text-xl text-gray-400 mb-12 text-center max-w-3xl mx-auto">
                    Specializing in robotics, computer vision, and human-robot interaction.
                </p>

                <section id="about" class="mb-16">
                    <h2 class="text-3xl font-bold mb-6 text-center">About Me</h2>
                    <div class="glass-card rounded-2xl p-6 max-w-4xl mx-auto">
                        <p class="text-gray-300 mb-4">
                            I'm pursuing a B.S. in Artificial Intelligence with a Minor in Neuroscience at Purdue University Indianapolis. 
                            My fascination lies at the intersection of artificial intelligence and human cognition – understanding how 
                            intelligent systems can interact with and learn from humans.
                        </p>
                        <p class="text-gray-300 mb-4">
                            Currently developing machine learning control algorithms for real-time robotic imitation at the University 
                            of Wyoming, I've enhanced system responsiveness by 40% using ROS, PyTorch, and OpenCV. My work integrates 
                            MonoDepth2 algorithms for high spatial accuracy in human-robot interaction.
                        </p>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-6">
                            <div class="text-center p-4 bg-gray-800 rounded-lg">
                                <span class="text-3xl font-bold text-purple-400 block">40%</span>
                                <span class="text-sm text-gray-400">System Responsiveness Improvement</span>
                            </div>
                            <div class="text-center p-4 bg-gray-800 rounded-lg">
                                <span class="text-3xl font-bold text-purple-400 block">25%</span>
                                <span class="text-sm text-gray-400">User Engagement Increase</span>
                            </div>
                            <div class="text-center p-4 bg-gray-800 rounded-lg">
                                <span class="text-3xl font-bold text-purple-400 block">15%</span>
                                <span class="text-sm text-gray-400">Data Security Enhancement</span>
                            </div>
                        </div>
                    </div>
                </section>

                <section id="projects" class="mb-16">
                    <h2 class="text-3xl font-bold mb-6 text-center">Featured Projects</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
                        <div class="glass-card rounded-2xl p-6 transform hover:scale-105 transition-transform duration-300">
                            <h3 class="text-2xl font-bold mb-2 text-purple-300">Robotic Imitation System</h3>
                            <p class="text-gray-400">Developed ML control algorithms for real-time robotic imitation, enhancing responsiveness by 40% using ROS and PyTorch.</p>
                        </div>
                        <div class="glass-card rounded-2xl p-6 transform hover:scale-105 transition-transform duration-300">
                            <h3 class="text-2xl font-bold mb-2 text-purple-300">Computer Vision Module</h3>
                            <p class="text-gray-400">Integrated MonoDepth2 algorithms with OpenCV for high spatial accuracy in human-robot interaction systems.</p>
                        </div>
                        <div class="glass-card rounded-2xl p-6 transform hover:scale-105 transition-transform duration-300">
                            <h3 class="text-2xl font-bold mb-2 text-purple-300">Interactive AI Interface</h3>
                            <p class="text-gray-400">Designed responsive AI interfaces for robotic systems, improving user engagement metrics by 25%.</p>
                        </div>
                    </div>
                </section>

                <section id="skills" class="mb-16">
                    <h2 class="text-3xl font-bold mb-6 text-center">Technical Expertise</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8">
                        <div class="glass-card rounded-2xl p-6">
                            <h3 class="text-xl font-bold mb-3 text-purple-300">Programming Languages</h3>
                            <ul class="text-gray-400 space-y-1">
                                <li>Python</li>
                                <li>C++</li>
                                <li>C#</li>
                                <li>Java</li>
                                <li>MATLAB</li>
                                <li>R</li>
                            </ul>
                        </div>
                        <div class="glass-card rounded-2xl p-6">
                            <h3 class="text-xl font-bold mb-3 text-purple-300">AI/Machine Learning</h3>
                            <ul class="text-gray-400 space-y-1">
                                <li>PyTorch</li>
                                <li>OpenCV</li>
                                <li>Computer Vision</li>
                                <li>Neural Networks</li>
                                <li>ROS 1</li>
                            </ul>
                        </div>
                        <div class="glass-card rounded-2xl p-6">
                            <h3 class="text-xl font-bold mb-3 text-purple-300">Developer Tools</h3>
                            <ul class="text-gray-400 space-y-1">
                                <li>Git</li>
                                <li>Docker</li>
                                <li>Google Cloud Platform</li>
                                <li>Unity</li>
                                <li>AutoCAD</li>
                            </ul>
                        </div>
                        <div class="glass-card rounded-2xl p-6">
                            <h3 class="text-xl font-bold mb-3 text-purple-300">Hardware Systems</h3>
                            <ul class="text-gray-400 space-y-1">
                                <li>System Design</li>
                                <li>Debugging</li>
                                <li>Embedded Systems</li>
                                <li>Software Design</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <section id="contact" class="mb-16">
                    <h2 class="text-3xl font-bold mb-6 text-center">Let's Build Something Amazing</h2>
                    <div class="glass-card rounded-2xl p-6 max-w-2xl mx-auto">
                        <div class="text-gray-300 space-y-3 text-center">
                            <div><strong>Email:</strong> erraymon@iu.edu</div>
                            <div><strong>Phone:</strong> (317) 835-5211</div>
                            <div><strong>Location:</strong> Indianapolis, IN</div>
                            <div class="flex justify-center space-x-6 mt-4">
                                <a href="https://linkedin.com/in/eric–raymond" target="_blank" class="text-purple-400 hover:text-purple-300">LinkedIn</a>
                                <a href="https://github.com/raayraay96" target="_blank" class="text-purple-400 hover:text-purple-300">GitHub</a>
                            </div>
                        </div>
                    </div>
                </section>
            </main>
            
            <footer class="text-center text-gray-500 py-12 mt-16">
                <p>&copy; 2025 Eric Raymond. All Rights Reserved.</p>
            </footer>

        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        let scene, camera, renderer;
        let arm, ikTarget;
        const mouse = new THREE.Vector2();
        let isMobile = window.innerWidth < 768;
        let isTablet = window.innerWidth >= 768 && window.innerWidth < 1024;
        let cameraDistance = isMobile ? 80 : isTablet ? 70 : 60;

        function init() {
            scene = new THREE.Scene();
            // No background color - let CSS background show through
            scene.fog = new THREE.Fog(0x0f172a, 50, 200);
            
            // Adaptive camera positioning
            camera = new THREE.PerspectiveCamera(
                isMobile ? 65 : 75, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            camera.position.set(
                isMobile ? 0 : 5, 
                isMobile ? 35 : 25, 
                cameraDistance
            );

            const canvas = document.getElementById('bg-canvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas, 
                antialias: true, 
                alpha: true,
                premultipliedAlpha: false,
                preserveDrawingBuffer: false
            });
            renderer.setClearColor(0x000000, 0); // Transparent background
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // Premium studio lighting setup
            const ambientLight = new THREE.AmbientLight(0x64748b, 0.3);
            scene.add(ambientLight);
            
            // Main key light
            const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
            keyLight.position.set(20, 40, 30);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = isMobile ? 1024 : 2048;
            keyLight.shadow.mapSize.height = isMobile ? 1024 : 2048;
            keyLight.shadow.camera.near = 0.1;
            keyLight.shadow.camera.far = 100;
            scene.add(keyLight);
            
            // Fill light
            const fillLight = new THREE.DirectionalLight(0x3b82f6, 0.4);
            fillLight.position.set(-20, 20, 20);
            scene.add(fillLight);
            
            // Accent rim light
            const rimLight = new THREE.PointLight(0x8b5cf6, 0.6, 100);
            rimLight.position.set(0, 30, -20);
            scene.add(rimLight);
            
            // Environment light for realism
            const envLight = new THREE.HemisphereLight(0x87ceeb, 0x2d3748, 0.4);
            scene.add(envLight);
            
            // Enable shadows
            renderer.shadowMap.enabled = !isMobile;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            ikTarget = new THREE.Object3D();
            scene.add(ikTarget);

            // Create the desk and monitor for hyperrealistic scene
            createDeskAndMonitor();
            
            arm = create7DofArm();
            scene.add(arm);
            // Adaptive arm positioning
            const armX = isMobile ? 0 : 25;
            const armY = isMobile ? -8 : -10;
            const armZ = isMobile ? -5 : 5;
            arm.position.set(armX, armY, armZ);

            // Define interaction points on the monitor corresponding to portfolio sections
            setupInteractionPoints();

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('touchmove', onTouchMove, false);
            window.addEventListener('touchstart', onTouchMove, false);
            
            // Mobile-specific optimizations
            if (isMobile) {
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                // Add subtle auto-animation for mobile
                setInterval(() => {
                    if (isMobile && Math.random() < 0.3) {
                        mouse.x = (Math.random() - 0.5) * 1.5;
                        mouse.y = (Math.random() - 0.5) * 1.5;
                    }
                }, 3000);
            }

            animate();
        }

        function createDeskAndMonitor() {
            // Premium desk with adaptive sizing
            const deskWidth = isMobile ? 80 : Math.max(120, window.innerWidth / 8);
            const deskDepth = isMobile ? 25 : 35;
            const deskGeometry = new THREE.BoxGeometry(deskWidth, 2, deskDepth);
            
            // Premium wood material with better texturing
            const deskMaterial = new THREE.MeshStandardMaterial({
                color: isMobile ? 0x4a5568 : 0x8B4513,
                roughness: 0.7,
                metalness: 0.15,
                bumpScale: 0.3,
                emissive: new THREE.Color(0x1a1a1a),
                emissiveIntensity: 0.02
            });
            const desk = new THREE.Mesh(deskGeometry, deskMaterial);
            desk.position.set(0, -12, 0);
            desk.receiveShadow = true;
            scene.add(desk);

            // Desk legs for more realism - ADAPTIVE TO DESK WIDTH
            const legGeometry = new THREE.BoxGeometry(1.5, 8, 1.5);
            const legMaterial = new THREE.MeshStandardMaterial({
                color: 0x654321,
                roughness: 0.8,
                metalness: 0.1
            });
            
            // Four desk legs - positioned based on desk width
            const legOffsetX = (deskWidth / 2) - 5;
            const leg1 = new THREE.Mesh(legGeometry, legMaterial);
            leg1.position.set(-legOffsetX, -16, 15);
            scene.add(leg1);
            
            const leg2 = new THREE.Mesh(legGeometry, legMaterial);
            leg2.position.set(legOffsetX, -16, 15);
            scene.add(leg2);
            
            const leg3 = new THREE.Mesh(legGeometry, legMaterial);
            leg3.position.set(-legOffsetX, -16, -15);
            scene.add(leg3);
            
            const leg4 = new THREE.Mesh(legGeometry, legMaterial);
            leg4.position.set(legOffsetX, -16, -15);
            scene.add(leg4);

            // Desk drawers
            const drawerGeometry = new THREE.BoxGeometry(12, 4, 3);
            const drawerMaterial = new THREE.MeshStandardMaterial({
                color: 0xA0522D,
                roughness: 0.8,
                metalness: 0.1
            });
            
            const drawer1 = new THREE.Mesh(drawerGeometry, drawerMaterial);
            drawer1.position.set(-15, -13, 13.5);
            scene.add(drawer1);
            
            const drawer2 = new THREE.Mesh(drawerGeometry, drawerMaterial);
            drawer2.position.set(15, -13, 13.5);
            scene.add(drawer2);

            // Drawer handles
            const handleGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const handleMaterial = new THREE.MeshStandardMaterial({
                color: 0xC0C0C0,
                metalness: 0.9,
                roughness: 0.1
            });
            
            const handle1 = new THREE.Mesh(handleGeometry, handleMaterial);
            handle1.position.set(-15, -13, 15.2);
            scene.add(handle1);
            
            const handle2 = new THREE.Mesh(handleGeometry, handleMaterial);
            handle2.position.set(15, -13, 15.2);
            scene.add(handle2);

            // Adding a desk mat for realism - FULL WIDTH
            const deskMatGeometry = new THREE.BoxGeometry(deskWidth - 4, 0.1, 25);
            const deskMatMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                roughness: 0.9,
                metalness: 0.05
            });
            const deskMat = new THREE.Mesh(deskMatGeometry, deskMatMaterial);
            deskMat.position.set(0, -10.9, 0);
            scene.add(deskMat);

            // Adding a notebook or papers
            const paperGeometry = new THREE.BoxGeometry(8, 0.2, 10);
            const paperMaterial = new THREE.MeshStandardMaterial({
                color: 0xdddddd,
                roughness: 0.7,
                metalness: 0.1
            });
            const paper = new THREE.Mesh(paperGeometry, paperMaterial);
            paper.position.set(-10, -10.8, 5);
            paper.rotation.y = Math.PI / 6;
            scene.add(paper);

            // Adding a pen
            const penGeometry = new THREE.CylinderGeometry(0.2, 0.2, 5, 8);
            const penMaterial = new THREE.MeshStandardMaterial({
                color: 0x2d3748,
                roughness: 0.5,
                metalness: 0.6
            });
            const pen = new THREE.Mesh(penGeometry, penMaterial);
            pen.position.set(-8, -10.7, 2);
            pen.rotation.z = Math.PI / 2;
            scene.add(pen);
        }

        function create7DofArm() {
            const armGroup = new THREE.Group();

            // Adaptive scale based on device
            const scale = isMobile ? 2.5 : isTablet ? 3.2 : 4.0;

            // Premium materials for desktop vs optimized for mobile
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: isMobile ? 0x6366f1 : 0x4f46e5,
                metalness: isMobile ? 0.7 : 0.9,
                roughness: isMobile ? 0.2 : 0.05,
                emissive: new THREE.Color(isMobile ? 0x312e81 : 0x1e1b4b),
                emissiveIntensity: isMobile ? 0.15 : 0.08,
                transparent: !isMobile,
                opacity: isMobile ? 1.0 : 0.85,
                envMapIntensity: isMobile ? 0.5 : 1.0
            });
            
            const ringMaterial = new THREE.MeshStandardMaterial({
                color: isMobile ? 0xf59e0b : 0xfbbf24,
                roughness: isMobile ? 0.4 : 0.2,
                metalness: isMobile ? 0.8 : 0.95,
                emissive: new THREE.Color(isMobile ? 0xd97706 : 0xf59e0b),
                emissiveIntensity: isMobile ? 0.3 : 0.6
            });
            
            // Enable shadows for desktop
            if (!isMobile) {
                bodyMaterial.shadowSide = THREE.DoubleSide;
                ringMaterial.shadowSide = THREE.DoubleSide;
            }

            // UPDATED: All arm lengths multiplied by the scale factor
            const armLength1 = 9 * scale;
            const armLength2 = 4 * scale;
            const armLength3 = 4 * scale;
            const totalForearmLength = armLength2 + armLength3;

            function createJoint(radius, ringThickness) {
                const jointGroup = new THREE.Group();
                const sphere = new THREE.Mesh(new THREE.SphereGeometry(radius, 20, 20), bodyMaterial);
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(radius, ringThickness, 8, 32),
                    ringMaterial
                );
                ring.rotation.x = Math.PI / 2;
                jointGroup.add(sphere);
                jointGroup.add(ring);
                return jointGroup;
            }

            // UPDATED: All geometry and positions are now scaled
            const base = new THREE.Mesh(new THREE.CylinderGeometry(2.5 * scale, 3.5 * scale, 1.5 * scale, 32), bodyMaterial);
            const baseRing = new THREE.Mesh(new THREE.TorusGeometry(2.5 * scale, 0.2 * scale, 8, 32), ringMaterial);
            baseRing.rotation.x = Math.PI / 2;
            baseRing.position.y = 0.75 * scale;
            base.add(baseRing);
            armGroup.add(base);

            const shoulder = new THREE.Group();
            shoulder.position.y = 0.75 * scale;
            base.add(shoulder);
            shoulder.add(createJoint(1.5 * scale, 0.2 * scale));

            const upperArm = new THREE.Group();
            shoulder.add(upperArm);
            const upperArmMesh = new THREE.Mesh(new THREE.CylinderGeometry(1.2 * scale, 0.9 * scale, armLength1, 20), bodyMaterial);
            upperArmMesh.position.y = armLength1 / 2;
            upperArm.add(upperArmMesh);

            const elbow = new THREE.Group();
            elbow.position.y = armLength1;
            upperArm.add(elbow);
            elbow.add(createJoint(1.1 * scale, 0.2 * scale));
            
            const forearm1 = new THREE.Group();
            elbow.add(forearm1);
            const forearm1Mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.9 * scale, 0.8 * scale, armLength2, 20), bodyMaterial);
            forearm1Mesh.position.y = armLength2 / 2;
            forearm1.add(forearm1Mesh);

            const midJoint = new THREE.Group();
            midJoint.position.y = armLength2;
            forearm1.add(midJoint);
            midJoint.add(createJoint(0.9 * scale, 0.15 * scale));

            const forearm2 = new THREE.Group();
            midJoint.add(forearm2);
            const forearm2Mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.8 * scale, 0.7 * scale, armLength3, 20), bodyMaterial);
            forearm2Mesh.position.y = armLength3 / 2;
            forearm2.add(forearm2Mesh);

            const wrist = new THREE.Group();
            wrist.position.y = armLength3;
            forearm2.add(wrist);
            wrist.add(createJoint(0.8 * scale, 0.15 * scale));

            const endEffector = new THREE.Group();
            endEffector.position.y = 0.5 * scale;
            
            // Main cylinder for the end effector (palm of the hand) - increased size
            const effectorBase = new THREE.Mesh(new THREE.CylinderGeometry(0.9 * scale, 0.9 * scale, 1.2 * scale, 20), bodyMaterial);
            effectorBase.position.y = 0;
            endEffector.add(effectorBase);
            
            // Ring for decoration - adjusted for larger size
            const endRing = new THREE.Mesh(new THREE.TorusGeometry(0.9 * scale, 0.15 * scale, 8, 32), ringMaterial);
            endRing.rotation.x = Math.PI / 2;
            endRing.position.y = 0.6 * scale;
            effectorBase.add(endRing);
            
            // Adding subtle panel lines or tech details on the effector base for a high-tech look
            const detailRing = new THREE.Mesh(new THREE.TorusGeometry(0.7 * scale, 0.05 * scale, 4, 24), ringMaterial);
            detailRing.rotation.x = Math.PI / 2;
            detailRing.position.y = 0.3 * scale;
            effectorBase.add(detailRing);
            
            // Adding a 3-finger hand to the end effector - increased size with refined design
            const fingerLength = 2.0 * scale;
            const fingerRadius = 0.2 * scale; // Slightly thinner for elegance
            
            // Finger 1 (left) with joint detail
            const finger1Base = new THREE.Mesh(new THREE.CylinderGeometry(fingerRadius, fingerRadius, fingerLength * 0.6, 8), bodyMaterial);
            finger1Base.position.set(-0.6 * scale, 0.9 * scale, 0);
            finger1Base.rotation.z = Math.PI / 6;
            endEffector.add(finger1Base);
            const finger1Tip = new THREE.Mesh(new THREE.CylinderGeometry(fingerRadius * 0.8, fingerRadius * 0.6, fingerLength * 0.4, 8), bodyMaterial);
            finger1Tip.position.set(-0.6 * scale, 1.5 * scale, 0);
            finger1Tip.rotation.z = Math.PI / 4;
            endEffector.add(finger1Tip);
            const joint1 = new THREE.Mesh(new THREE.SphereGeometry(fingerRadius * 1.2, 8, 8), ringMaterial);
            joint1.position.set(-0.6 * scale, 1.2 * scale, 0);
            endEffector.add(joint1);
            
            // Finger 2 (middle) with joint detail
            const finger2Base = new THREE.Mesh(new THREE.CylinderGeometry(fingerRadius, fingerRadius, fingerLength * 0.6, 8), bodyMaterial);
            finger2Base.position.set(0, 0.9 * scale, 0);
            endEffector.add(finger2Base);
            const finger2Tip = new THREE.Mesh(new THREE.CylinderGeometry(fingerRadius * 0.8, fingerRadius * 0.6, fingerLength * 0.4, 8), bodyMaterial);
            finger2Tip.position.set(0, 1.5 * scale, 0);
            finger2Tip.rotation.z = Math.PI / 12;
            endEffector.add(finger2Tip);
            const joint2 = new THREE.Mesh(new THREE.SphereGeometry(fingerRadius * 1.2, 8, 8), ringMaterial);
            joint2.position.set(0, 1.2 * scale, 0);
            endEffector.add(joint2);
            
            // Finger 3 (right) with joint detail
            const finger3Base = new THREE.Mesh(new THREE.CylinderGeometry(fingerRadius, fingerRadius, fingerLength * 0.6, 8), bodyMaterial);
            finger3Base.position.set(0.6 * scale, 0.9 * scale, 0);
            finger3Base.rotation.z = -Math.PI / 6;
            endEffector.add(finger3Base);
            const finger3Tip = new THREE.Mesh(new THREE.CylinderGeometry(fingerRadius * 0.8, fingerRadius * 0.6, fingerLength * 0.4, 8), bodyMaterial);
            finger3Tip.position.set(0.6 * scale, 1.5 * scale, 0);
            finger3Tip.rotation.z = -Math.PI / 4;
            endEffector.add(finger3Tip);
            const joint3 = new THREE.Mesh(new THREE.SphereGeometry(fingerRadius * 1.2, 8, 8), ringMaterial);
            joint3.position.set(0.6 * scale, 1.2 * scale, 0);
            endEffector.add(joint3);
            
            wrist.add(endEffector);
            
            armGroup.userData.joints = { base, shoulder, elbow, midJoint, wrist };
            armGroup.userData.armLengths = { l1: armLength1, l2: totalForearmLength };

            return armGroup;
        }

        function onWindowResize() {
            // Update device detection
            const wasMobile = isMobile;
            isMobile = window.innerWidth < 768;
            isTablet = window.innerWidth >= 768 && window.innerWidth < 1024;
            
            // Recreate scene if device type changed
            if (wasMobile !== isMobile) {
                scene.clear();
                createDeskAndMonitor();
                arm = create7DofArm();
                scene.add(arm);
                setupInteractionPoints();
            }
            
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }
        
        // Add touch support for mobile
        function onTouchMove(event) {
            if (event.touches.length > 0) {
                const touch = event.touches[0];
                mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            }
        }
        
        const raycaster = new THREE.Raycaster();
        const targetPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); 
        const targetPos = new THREE.Vector3();
        let currentTargetPoint = null;

        function animate() {
            requestAnimationFrame(animate);

            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(targetPlane, targetPos);
            
            // Check if mouse position corresponds to a portfolio section
            const targetPoint = getInteractionPointFromMouse(mouse.x, mouse.y);
            if (targetPoint) {
                currentTargetPoint = targetPoint;
                ikTarget.position.lerp(currentTargetPoint, 0.15); // Smoother movement
            } else {
                // Enhanced smooth movement with bounds checking
                const boundedTarget = new THREE.Vector3(
                    THREE.MathUtils.clamp(targetPos.x, -40, 40),
                    THREE.MathUtils.clamp(targetPos.y, -15, 20),
                    THREE.MathUtils.clamp(targetPos.z, -10, 25)
                );
                ikTarget.position.lerp(boundedTarget, 0.12);
            }

            if (arm && arm.userData.joints) {
                const { base, shoulder, elbow, midJoint, wrist } = arm.userData.joints;
                const { l1, l2 } = arm.userData.armLengths;
                
                const localTarget = arm.worldToLocal(ikTarget.position.clone());
                const angleY = Math.atan2(localTarget.x, localTarget.z);
                base.rotation.y = THREE.MathUtils.lerp(base.rotation.y, angleY, 0.1);
                
                const y = localTarget.y - shoulder.position.y;
                const flatDist = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);
                const dist = Math.sqrt(flatDist * flatDist + y * y);

                let shoulderTargetRot, totalBendRot;

                if (dist > l1 + l2) {
                    shoulderTargetRot = Math.atan2(y, flatDist);
                    totalBendRot = 0;
                } else {
                    const a1 = Math.atan2(y, flatDist);
                    const cos_a2 = THREE.MathUtils.clamp((dist * dist + l1 * l1 - l2 * l2) / (2 * dist * l1), -1, 1);
                    const a2 = Math.acos(cos_a2);
                    shoulderTargetRot = a1 + a2;

                    const cos_b = THREE.MathUtils.clamp((l1 * l1 + l2 * l2 - dist * dist) / (2 * l1 * l2), -1, 1);
                    totalBendRot = Math.acos(cos_b) - Math.PI;
                }

                shoulderTargetRot = THREE.MathUtils.clamp(shoulderTargetRot, -Math.PI / 2, Math.PI / 2);
                totalBendRot = THREE.MathUtils.clamp(totalBendRot, -Math.PI * 0.9, 0);

                const elbowRot = totalBendRot * 0.6;
                const midJointRot = totalBendRot * 0.4;

                // Device-adaptive kinematics
                const lerpSpeed = isMobile ? 0.12 : 0.08;
                shoulder.rotation.x = THREE.MathUtils.lerp(shoulder.rotation.x, shoulderTargetRot, lerpSpeed);
                elbow.rotation.x = THREE.MathUtils.lerp(elbow.rotation.x, elbowRot, lerpSpeed);
                midJoint.rotation.x = THREE.MathUtils.lerp(midJoint.rotation.x, midJointRot, lerpSpeed);
                
                // Enhanced natural movement
                const time = Date.now() * 0.001;
                wrist.rotation.z = THREE.MathUtils.lerp(
                    wrist.rotation.z, 
                    Math.sin(time) * 0.1 + Math.cos(time * 0.7) * 0.05, 
                    0.05
                );
                
                // Subtle breathing animation for the base
                base.scale.y = 1 + Math.sin(time * 0.5) * 0.02;

                const targetWorldPos = new THREE.Vector3();
                ikTarget.getWorldPosition(targetWorldPos);
                wrist.lookAt(targetWorldPos);
            }
            
            renderer.render(scene, camera);
        }

        // Interaction points corresponding to portfolio sections on the monitor
        let interactionPoints = [];

        function setupInteractionPoints() {
            // Device-adaptive interaction points
            const reach = isMobile ? 15 : 30;
            const forwardReach = isMobile ? 10 : 15;
            
            interactionPoints = [
                { name: 'home', x: 0, y: -5, z: forwardReach },
                { name: 'about', x: -reach, y: -5, z: forwardReach },
                { name: 'projects', x: reach, y: -5, z: forwardReach },
                { name: 'skills', x: -reach * 0.7, y: -5, z: forwardReach * 0.7 },
                { name: 'contact', x: reach * 0.7, y: -5, z: forwardReach * 0.7 }
            ];
        }

        function getInteractionPointFromMouse(mouseX, mouseY) {
            // Map mouse coordinates to approximate portfolio section areas
            // This is a simplified mapping based on screen quadrants
            if (mouseY > 0.5) {
                return new THREE.Vector3(interactionPoints[0].x, interactionPoints[0].y, interactionPoints[0].z); // Home
            } else if (mouseY > 0 && mouseX < 0) {
                return new THREE.Vector3(interactionPoints[1].x, interactionPoints[1].y, interactionPoints[1].z); // About
            } else if (mouseY > 0 && mouseX >= 0) {
                return new THREE.Vector3(interactionPoints[2].x, interactionPoints[2].y, interactionPoints[2].z); // Projects
            } else if (mouseY <= 0 && mouseX < 0) {
                return new THREE.Vector3(interactionPoints[3].x, interactionPoints[3].y, interactionPoints[3].z); // Skills
            } else if (mouseY <= 0 && mouseX >= 0) {
                return new THREE.Vector3(interactionPoints[4].x, interactionPoints[4].y, interactionPoints[4].z); // Contact
            }
            return null;
        }

        // Performance monitoring for mobile
        let frameCount = 0;
        let lastTime = Date.now();
        
        function checkPerformance() {
            frameCount++;
            const now = Date.now();
            if (now - lastTime > 1000) {
                const fps = frameCount;
                frameCount = 0;
                lastTime = now;
                
                // Reduce quality on mobile if performance is poor
                if (isMobile && fps < 30) {
                    renderer.setPixelRatio(1);
                    scene.fog.far = 100;
                }
            }
        }
        
        // Enhanced animate function with performance monitoring
        const originalAnimate = animate;
        animate = function() {
            checkPerformance();
            originalAnimate();
        };
        
        init();
    </script>

</body>
</html>
